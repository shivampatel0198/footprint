package main

import (
	"math"
)

// Given a collection of records, computes the number of infected nodes in each point
func count(record []NodeRecord) (out map[Point]int, tot int) {
	out = make(map[Point]int)
	for _, nr := range record {
		if nr.Infected {
			out[nr.Loc]++
			tot++
		}
	}
	return
}

func weighting(t, T int) float64 {
	return math.Pow(0.5, float64(T-t+1))
}

func sum(ms []map[Point]int) (out map[Point]int) {
	out = make(map[Point]int)
	for _, m := range ms {
		for p, x := range m {
			out[p] += x
		}
	}
	return
}

// Returns a single heatmap for time t
func heatmap(t int, record [][]NodeRecord) (out map[Point]float64) {
	out = make(map[Point]float64)

	// List of maps from points to the total number of times they have been
	// visited by infected nodes in time [0,t]
	counts := make([]map[Point]int, t+1)

	// Count total number of infected visits to any node
	total := 0
	for i, snapshot := range record[:t+1] {
		tmp := 0
		counts[i], tmp = count(snapshot)
		total += tmp
	}
	for p, x := range sum(counts) {
		out[p] = float64(x) / float64(total)
	}
	return
}

// Layers together all heatmaps between time 0 and t, inclusive,
// weighting layers closer to time t more heavily 
// (the kth most recent layer has weight (1/2)^k)
func cumulative_heatmap(t int, record[][]NodeRecord) (out map[Point]float64) {
	out = make(map[Point]float64)
	for i:=0; i<=t; i++ {
		for p, f := range heatmap(i, record) {
			out[p] += f * weighting(i,t)
		}
	}
	return
}

// Returns all cumulative heatmaps generated by record
func CumulativeHeatmaps(record [][]NodeRecord) (out []map[Point]float64) {
	out = make([]map[Point]float64, len(record))
	for t := range record {
		out[t] = cumulative_heatmap(t, record)
	}
	return
}
