<!DOCTYPE html>

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v5.min.js"></script>

<!-- Add styles -->
<style>
    html, body {
        background-color: white;
        width: 100%;
        height: auto;
    }

    .axis line {
        stroke: lightgray;
    }

</style>


<!-- Draw the webpage -->
<body></body>

<!-- Define visualization in D3 -->
<script> 

    // DESIGN CONSTANTS
    const width  = 600;
    const height = 600;

    var X_LO = Infinity, X_HI = -Infinity, Y_LO = Infinity, Y_HI = -Infinity;

    const dotRadius = 3;

    // HTML CONSTANTS
    parentNode = d3.select('body');

    // The SVG element in the DOM. This is our chart
    const svg = parentNode.append("svg")
        .attr("width", width)
        .attr("height", height);
    
    // Draws an infected node
    function drawNodeAt(x, y) {
        let newCoords = modelToViewCoordinates(x,y);
        svg.append("circle")
            .attr("fill", "black")
            .attr("transform", `translate(${newCoords[0]} ${newCoords[1]})`)
            .attr("r", dotRadius);
    }

    function modelToViewXDisplacement(x) {
        return (width / (X_HI - X_LO)) * x;
    }

    function modelToViewYDisplacement(y) {
        return (height / (Y_LO - Y_HI)) * y;
    }

    // Converts coordinates
    function modelToViewCoordinates(x, y) {
        let new_x = ((width / (X_HI - X_LO)) * x) + ((width * -X_LO) / (X_HI - X_LO));
        let new_y = ((height / (Y_LO - Y_HI)) * y) + ((height * -Y_HI) / (Y_LO - Y_HI));
        return [new_x, new_y];
    }

    // (1) Fetch data
    var data = [
        [
            {"Loc": {"X" : 10, "Y": 10} },
            {"Loc": {"X" : 8, "Y": 8} },
            {"Loc": {"X" : 6, "Y": 6} },
            {"Loc": {"X" : 4, "Y": 4} },
            {"Loc": {"X" : 2, "Y": 2} },
            {"Loc": {"X" : 0, "Y": 0} },
            {"Loc": {"X" : -2, "Y": -2} },
            {"Loc": {"X" : -4, "Y": -4} },
            {"Loc": {"X" : -6, "Y": -6} },
            {"Loc": {"X" : -8, "Y": -8} }, 
            {"Loc": {"X" : -10, "Y": -10} },
        ]
    ];

    scaleAxes();
    visualize();

    // (2) Scale the axes
    function scaleAxes() {
        
        // Find grid bounds
        for(var i = 0; i < data.length; i++) {
            
            var smallest = Infinity, highest = -Infinity;
            
            for(var j = 0; j < data[i].length; j++) {
                if (data[i][j].Loc.X < smallest) smallest = data[i][j].Loc.X;
                if (data[i][j].Loc.X > highest) highest = data[i][j].Loc.X;
                if (data[i][j].Loc.Y < smallest) smallest = data[i][j].Loc.Y;
                if (data[i][j].Loc.Y > highest) highest = data[i][j].Loc.Y;
            }

            X_LO = Y_LO = smallest;
            X_HI = Y_HI = highest;
        }

        // Make linear scales
        var x = d3.scaleLinear().domain([X_LO, X_HI]).range([0, width]);
        var y = d3.scaleLinear().domain([Y_HI, Y_LO]).range([0, height]);
        
        // Construct axes
        var xAxis = d3.axisBottom()
            .scale(x)
            .tickSize(height)       // Add gridlines
            .tickFormat("");
        var yAxis = d3.axisRight()
            .scale(y)
            .tickSize(width)        // Add gridlines
            .tickFormat("");

        // Add the opposite-side axes to complete the outer square
        var bottom = d3.axisTop()
            .scale(x);
            //.tickFormat("");
        var right = d3.axisLeft()
            .scale(y);
            //.tickFormat("");        

        // Draw all four axes
        svg.append("g")
            .attr("class", "x axis")
            .call(xAxis);
        
        svg.append("g")
            .attr("class", "y axis")
            .call(yAxis);

        svg.append("g")
            .attr("class", "x axis")
            .attr("transform", `translate(0 ${height - 1})`)
            .call(bottom);

        svg.append("g")
            .attr("class", "y axis")
            .attr("transform", `translate(${width - 1})`)
            .call(right);

    }

    // (3) Build the visuals
    function visualize() {

        // Start by drawing the initial nodes
        const currentTimestep = data[0];
        for (const node of currentTimestep) {
            console.log(node);
            drawNodeAt(node.Loc.X, node.Loc.Y);
        }
    }

</script>